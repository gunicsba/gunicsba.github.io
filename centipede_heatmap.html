<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RTK Heatmap (offline-ish)</title>
  <style>
    :root { --card:#fff; --border:#ddd; --muted:#666; --bg:#f6f6f6; }
    body{font-family:system-ui,Segoe UI,Arial;margin:0;background:var(--bg);color:#111}
    header{padding:14px 16px;border-bottom:1px solid var(--border);background:#fff}
    h1{font-size:18px;margin:0}
    .wrap{padding:14px 16px;display:flex;flex-direction:column;gap:12px}
    canvas{border:1px solid var(--border);border-radius:12px;max-width:100%;height:auto;background:transparent}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end}
    label{display:block;font-size:12px;color:#333;margin-bottom:4px}
    input,select,button,textarea{padding:8px;font-size:14px}
    button{cursor:pointer}
    .small{font-size:12px;color:var(--muted)}
    .kv{display:grid;grid-template-columns:160px 1fr;gap:10px;align-items:center}
    .kv label{margin:0}
    details summary{cursor:pointer;font-weight:600}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .status{margin-top:8px}
  </style>
</head>
<body>
<header>
  <h1>RTK Base Heatmap (HU + N SRB + RO + SK buffer)</h1>
</header>

<div class="wrap">

  <!-- CANVAS FIRST -->
  <div class="card">
    <canvas id="cv" width="2400" height="1600"></canvas>
    <div id="status" class="small status"></div>
    <div class="row" style="margin-top:10px">
      <button id="regen">Regenerate</button>
      <button id="dl" disabled>Download PNG</button>
    </div>
  </div>

  <!-- SETTINGS AT THE BOTTOM -->
  <div class="card">
    <details open>
      <summary>Settings</summary>
      <div class="small" style="margin:8px 0 10px 0">
        A GeoJSON fájlokat a HTML mellől tölti: <span class="mono">countries.geojson</span> és <span class="mono">rivers.geojson</span>.
        A bázislistát URL-ről próbálja (<span class="mono">crtkUrl</span>), CORS esetén file feltöltéssel pótolható.
      </div>

      <div class="row">
        <div class="card" style="padding:10px">
          <label>crtk.net forrás URL (TXT)</label>
          <input id="crtkUrl" class="mono" style="width:min(860px, 90vw)" value="https://crtk.net/" />
          <div class="small">Ha a szerver nem enged CORS-t, a böngésző blokkolni fogja. Ilyenkor töltsd fel fájlból lent.</div>
        </div>

        <div class="card" style="padding:10px">
          <label>Fallback: crtk.net fájl (ha CORS blokkol)</label>
          <input id="crtkFile" type="file" accept=".txt,.net,.dat,.csv" />
          <div class="small">STR sorok: <span class="mono">STR;mount;country;...;lat;lon;...</span> → name=mount (p[1])</div>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div class="card" style="padding:10px">
          <label>Kimenet (px)</label>
          <div class="row">
            <div>
              <label>Szélesség</label>
              <input id="w" type="number" value="4800" min="200" step="100"/>
            </div>
            <div>
              <label>Magasság</label>
              <input id="h" type="number" value="3200" min="200" step="100"/>
            </div>
            <div>
              <label>PoligonMéret (km)</label>
              <input id="hexkm" type="number" value="3" min="2" step="1"/>
            </div>
          </div>
          <div class="small">Nagy méretnél (pl. 20000×10000) a böngésző/RAM lehet a limit.</div>
        </div>

        <div class="card" style="padding:10px;display: none;">
          <label>Hatótáv / heat</label>
          <div class="row">
            <div>
              <label>Radius (km)</label>
              <input id="rkm" type="number" value="35" min="1" step="1"/>
            </div>
            <div>
              <label>Mód</label>
              <select id="mode">
                <option value="gauss" selected>Gaussian (sima)</option>
                <option value="hard">Hard cutoff (éles)</option>
                <option value="none">Nincs</option>
              </select>
            </div>
          </div>
        </div>

        <div class="card" style="padding:10px">
          <label>Háttér</label>
          <div class="row">
            <label><input id="bgMap" type="checkbox" checked/> Offline háttér (rács+felirat)</label>
            <label><input id="transparent" type="checkbox"/> Átlátszó háttér</label>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div class="card" style="padding:10px; min-width:320px">
          <label>Layer: ország-határok</label>
          <div class="row">
            <label><input id="bordersOn" type="checkbox" checked/> bekapcsolva</label>
            <div>
              <label>Szín</label>
              <input id="bordersColor" type="color" value="#444444"/>
            </div>
            <div>
              <label>Vastagság</label>
              <input id="bordersW" type="number" value="4" min="1" step="1"/>
            </div>
            <div>
              <label>Alpha</label>
              <input id="bordersA" type="number" value="0.65" min="0" max="1" step="0.05"/>
            </div>
          </div>
          <div class="small">Forrás: <span class="mono">./countries.geojson</span></div>
        </div>

        <div class="card" style="padding:10px; min-width:320px">
          <label>Layer: vizek</label>
          <div class="row">
            <label><input id="watersOn" type="checkbox" checked/> bekapcsolva</label>
            <div>
              <label>Szín</label>
              <input id="watersColor" type="color" value="#3b82f6"/>
            </div>
            <div>
              <label>Vastagság</label>
              <input id="watersW" type="number" value="5" min="1" step="1"/>
            </div>
            <div>
              <label>Alpha</label>
              <input id="watersA" type="number" value="0.65" min="0" max="1" step="0.05"/>
            </div>
          </div>
          <div class="small">Forrás: <span class="mono">./waters_merged.geojson</span></div>
        </div>

        <div class="card" style="padding:10px; min-width:320px">
          <label>Feliratok / jelmagyarázat</label>
          <div class="row">
            <label><input id="labelsOn" type="checkbox" checked/> Bázisnevek</label>
            <label><input id="legendOn" type="checkbox" checked/> Jelmagyarázat</label>
          </div>

          <div class="kv" style="margin-top:8px">
            <label>Label szín</label><input id="labelColor" type="color" value="#0b3d0b"/>
            <label>Label font</label><input id="labelFont" value="DejaVu Sans, Arial, sans-serif"/>
            <label>Label méret</label><input id="labelFS" type="number" value="14" min="8" step="1"/>
            <label>Halo szín</label><input id="labelOutline" type="color" value="#ffffff"/>
            <label>Halo vast.</label><input id="labelOutlineW" type="number" value="3" min="0" step="1"/>
            <label>Eltolás X/Y</label>
            <div class="row">
              <input id="labelDX" type="number" value="6" step="1" style="width:100px"/>
              <input id="labelDY" type="number" value="-6" step="1" style="width:100px"/>
            </div>
            <label>Legend title</label><input id="legendTitle" value="RTK Base density (20 km)" />
            <label>Legend size</label>
            <input id="legendScale" type="number" value="1.6" min="0.6" max="4" step="0.1">
            <div class="small">1.0 = alap, 1.6–2.4 projektoros/nyomdás nézethez jó.</div>
          </div>
        </div>
      </div>
      <div id="tip" style="
  position:fixed; left:0; top:0; display:none;
  background:rgba(255,255,255,0.92);
  border:1px solid rgba(0,0,0,0.15);
  border-radius:10px; padding:10px;
  font:12px system-ui; color:#111;
  max-width:340px; pointer-events:none;
"></div>

    </details>
  </div>
</div>

<script>
/** BBOX: HU + N Serbia + RO overlap + ~100 km Slovakia buffer */
const bbox = { minLon:16.0, maxLon:24.5, minLat:44.5, maxLat:49.8 };


const thresholds = [
  { max: 7,  color: "rgba(0, 120, 0, 0.45)", label: "0–7 km" }, // dark green
  { max: 20, color: "rgba(0, 180, 0, 0.40)", label: "7–20 km" }, // green
  { max: 35, color: "rgba(240, 200, 0, 0.40)", label: "20–35 km" }, // yellow
  { max: 50, color: "rgba(255, 140, 0, 0.40)", label: "35–50 km" }, // orange
  { max: Infinity, color: "rgba(200, 0, 0, 0.40)", label: ">50 km" } // red
];

function $(id){ return document.getElementById(id); }
function setStatus(msg){ $("status").textContent = msg; }

function hexToRgba(hex, a){
  const h = hex.replace("#","");
  const r = parseInt(h.slice(0,2),16);
  const g = parseInt(h.slice(2,4),16);
  const b = parseInt(h.slice(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}

function lonLatToXY(lon, lat, W, H){
  const x = (lon - bbox.minLon) / (bbox.maxLon - bbox.minLon) * (W - 1);
  const y = (bbox.maxLat - lat) / (bbox.maxLat - bbox.minLat) * (H - 1);
  return {x, y};
}

function kmPerPx(W,H){
  const midLat = (bbox.minLat + bbox.maxLat) / 2;
  const kmPerDegLat = 111.0;
  const kmPerDegLon = 111.0 * Math.cos(midLat * Math.PI/180);
  const degPerPxX = (bbox.maxLon - bbox.minLon) / W;
  const degPerPxY = (bbox.maxLat - bbox.minLat) / H;
  return { x: degPerPxX * kmPerDegLon, y: degPerPxY * kmPerDegLat };
}

/** NAME FIX: STR;mount;country;...;lat;lon;... -> name = mount (p[1]), country = p[2] */
function parseSTR(text){
  const pts = [];
  for (const line of text.split(/\r?\n/)){
    if (!line.startsWith("STR;")) continue;
    const p = line.split(";");
    if (p.length < 11) continue;

    const mount = (p[1] || "").trim();
    const country = (p[2] || "").trim();
    const lat = Number(p[9]);
    const lon = Number(p[10]);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
    if (lat < bbox.minLat || lat > bbox.maxLat || lon < bbox.minLon || lon > bbox.maxLon) continue;

    pts.push({ lat, lon, name: mount || "BASE", country });
  }
  return pts;
}

function drawOfflineBg(ctx, W, H){
  ctx.save();
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "rgb(245,245,245)";
  ctx.fillRect(0,0,W,H);

  // grid
  ctx.strokeStyle = "rgb(220,220,220)";
  ctx.lineWidth = 1;
  for (let lon = 16; lon <= 25; lon++){
    const x = (lon - bbox.minLon) / (bbox.maxLon - bbox.minLon) * W;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
  }
  for (let lat = 45; lat <= 50; lat++){
    const y = (bbox.maxLat - lat) / (bbox.maxLat - bbox.minLat) * H;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  // labels
  ctx.fillStyle = "rgb(180,180,180)";
  ctx.font = `${Math.max(24, Math.floor(W/50))}px sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const labels = [
    ["Magyarország", 0.45, 0.45],
    ["Szerbia",  0.45, 0.75],
    ["Románia", 0.78, 0.55],
    ["Szlovákia",0.45, 0.15],
  ];
  for (const [t, fx, fy] of labels) ctx.fillText(t, fx*W, fy*H);

  ctx.restore();
}

/** Heatmap via splat gradients, then colorize */
function drawHeatLayer(W,H,pts,radiusKm,mode){
  const k = kmPerPx(W,H);
  const rpx = radiusKm / Math.sqrt(k.x * k.y);
  const r = Math.max(2, rpx);

  const off = document.createElement("canvas");
  off.width = W; off.height = H;
  const octx = off.getContext("2d", { willReadFrequently:false });
  octx.clearRect(0,0,W,H);
  octx.globalCompositeOperation = "lighter";

  for (let i=0;i<pts.length;i++){
    const {x,y} = lonLatToXY(pts[i].lon, pts[i].lat, W, H);
    const g = octx.createRadialGradient(x,y,0, x,y,r);
    if (mode === "hard"){
      g.addColorStop(0.0, "rgba(0,255,0,0.20)");
      g.addColorStop(0.999, "rgba(0,255,0,0.20)");
      g.addColorStop(1.0, "rgba(0,255,0,0.0)");
    } else if (mode === "soft") {
      g.addColorStop(0.0, "rgba(0,255,0,0.22)");
      g.addColorStop(0.35,"rgba(0,255,0,0.12)");
      g.addColorStop(0.70,"rgba(0,255,0,0.05)");
      g.addColorStop(1.0, "rgba(0,255,0,0.0)");
    }
    if( mode != "none") {
      octx.fillStyle = g;
      octx.beginPath();
      octx.arc(x,y,r,0,Math.PI*2);
      octx.fill();
    }

    if (i % 80 === 0) setStatus(`Heat splat: ${i}/${pts.length}`);
  }

  const img = octx.getImageData(0,0,W,H);
  const d = img.data;

  let maxA = 1;
  for (let i=3;i<d.length;i+=4) if (d[i] > maxA) maxA = d[i];

  const gamma = 0.6;
  for (let i=0;i<d.length;i+=4){
    const a = d[i+3] / maxA;
    if (a <= 0.01){ d[i+3] = 0; continue; }
    const v = Math.pow(a, gamma);
    d[i]   = 0;
    d[i+1] = Math.round(90 + (255-90)*v);
    d[i+2] = 0;
    d[i+3] = Math.round(50 + (255-50)*v);
  }

  octx.putImageData(img,0,0);
  return off;
}

function haversineKm(lat1, lon1, lat2, lon2){
  const R = 6371.0;
  const toRad = d => d * Math.PI/180;
  const dLat = toRad(lat2-lat1);
  const dLon = toRad(lon2-lon1);
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}

let hexCache = []; // [{cx,cy, lat,lon, dNearest, bandIndex}...]

function drawHexDistanceLayer(ctx, W, H, bases, hexKm, thresholds){
  hexCache = [];

  const k = kmPerPx(W,H);
  const kmPerPxMean = Math.sqrt(k.x * k.y);
  const hexR = Math.max(2, hexKm / kmPerPxMean);

  const dx = hexR * 1.5;
  const dy = hexR * Math.sqrt(3);

  const blats = bases.map(b=>b.lat);
  const blons = bases.map(b=>b.lon);

  function bandIndexFor(d){
    for (let i=0;i<thresholds.length;i++){
      if (d <= thresholds[i].max) return i;
    }
    return thresholds.length-1;
  }

  function colorForBand(i){ return thresholds[i].color; }

  for (let row=0, y=hexR; y < H+hexR; y += dy, row++){
    const xOffset = (row % 2) ? dx/2 : 0;
    for (let x=hexR + xOffset; x < W+hexR; x += dx){

      const lon = bbox.minLon + (x / (W - 1)) * (bbox.maxLon - bbox.minLon);
      const lat = bbox.maxLat - (y / (H - 1)) * (bbox.maxLat - bbox.minLat);

      let best = Infinity;
      for (let i=0;i<blats.length;i++){
        const d = haversineKm(lat, lon, blats[i], blons[i]);
        if (d < best) best = d;
      }

      const bi = bandIndexFor(best);
      ctx.fillStyle = colorForBand(bi);

      // draw hex
      ctx.beginPath();
      for (let i=0;i<6;i++){
        const a = (Math.PI/180) * (60*i - 30);
        const px = x + hexR * Math.cos(a);
        const py = y + hexR * Math.sin(a);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.fill();

      hexCache.push({ cx:x, cy:y, lat, lon, dNearest:best, bandIndex:bi, r:pxToNum(hexR) });
    }
  }

  // store radius for picking
  window.__hexR = hexR;
}

function pxToNum(v){ return Number(v); }


let hexIndex = new Map(); // key = "gx:gy" -> [hexIds...]

function buildHexIndex(hexR){
  hexIndex = new Map();
  const cell = hexR * 2.0;

  for (let i=0;i<hexCache.length;i++){
    const h = hexCache[i];
    const gx = Math.floor(h.cx / cell);
    const gy = Math.floor(h.cy / cell);
    const key = `${gx}:${gy}`;
    if (!hexIndex.has(key)) hexIndex.set(key, []);
    hexIndex.get(key).push(i);
  }
  window.__hexCell = cell;
}

function pickHex(mx, my){
  const cell = window.__hexCell || (window.__hexR*2);
  const gx = Math.floor(mx / cell);
  const gy = Math.floor(my / cell);

  let bestId = -1;
  let bestD2 = Infinity;

  for (let yy=gy-1; yy<=gy+1; yy++){
    for (let xx=gx-1; xx<=gx+1; xx++){
      const key = `${xx}:${yy}`;
      const ids = hexIndex.get(key);
      if (!ids) continue;
      for (const id of ids){
        const h = hexCache[id];
        const dx = mx - h.cx;
        const dy = my - h.cy;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2){
          bestD2 = d2;
          bestId = id;
        }
      }
    }
  }

  // opcionálisan: ha túl messze van a középponttól, nincs találat
  const maxR = window.__hexR * 1.2;
  if (bestId >= 0 && bestD2 <= maxR*maxR) return bestId;
  return -1;
}



/** GeoJSON drawing */
function normalizeGeoJSON(gj){
  if (!gj) return [];
  if (gj.type === "FeatureCollection") return gj.features || [];
  if (gj.type === "Feature") return [gj];
  if (gj.type && gj.coordinates) return [{ type:"Feature", properties:{}, geometry:gj }];
  return [];
}

function drawGeometry(ctx, W, H, geom, style){
  const proj = (pt) => {
    const lon = pt[0], lat = pt[1];
    const {x,y} = lonLatToXY(lon, lat, W, H);
    return [x,y];
  };

  function drawLineString(coords){
    if (!coords || coords.length < 2) return;
    ctx.beginPath();
    const [x0,y0] = proj(coords[0]);
    ctx.moveTo(x0,y0);
    for (let i=1;i<coords.length;i++){
      const [x,y] = proj(coords[i]);
      ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  function drawPolygon(rings){
    if (!rings || rings.length === 0) return;
    ctx.beginPath();
    for (const ring of rings){
      if (!ring || ring.length < 3) continue;
      const [x0,y0] = proj(ring[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<ring.length;i++){
        const [x,y] = proj(ring[i]);
        ctx.lineTo(x,y);
      }
      ctx.closePath();
    }
    if (style.fillStyle){
      ctx.save();
      ctx.globalAlpha = style.fillAlpha ?? 0.25;
      ctx.fillStyle = style.fillStyle;
      ctx.fill();
      ctx.restore();
    }
    ctx.stroke();
  }

  ctx.save();
  ctx.strokeStyle = style.strokeStyle;
  ctx.lineWidth = style.lineWidth;
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  if (geom.type === "LineString") drawLineString(geom.coordinates);
  else if (geom.type === "MultiLineString") geom.coordinates.forEach(drawLineString);
  else if (geom.type === "Polygon") drawPolygon(geom.coordinates);
  else if (geom.type === "MultiPolygon") geom.coordinates.forEach(drawPolygon);

  ctx.restore();
}

async function fetchJSON(url){
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`Fetch failed: ${url} (${res.status})`);
  return await res.json();
}

async function fetchText(url){
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`Fetch failed: ${url} (${res.status})`);
  return await res.text();
}

async function loadCrtkText(){
  const url = $("crtkUrl").value.trim();
  try {
    setStatus(`Fetching CRKT list: ${url} ...`);
    const txt = await fetchText(url);
    return txt;
  } catch (e) {
    // fallback: file
    const f = $("crtkFile").files && $("crtkFile").files[0];
    if (!f) throw new Error(`CRTK URL blocked/failed, and no file selected. Error: ${e.message}`);
    setStatus(`CRTK fetch failed (${e.message}). Using file: ${f.name}`);
    return await f.text();
  }
}

function drawLegendFromThresholds(ctx, W, H, thresholds, title, pos="br", scale=1.0){
  if (!$("legendOn").checked) return;

  // base sizes (scaled)
  const pad = Math.round(16 * scale);
  const fs  = Math.round(14 * scale);
  const box = Math.round(14 * scale);
  const gap = Math.round(8  * scale);
  const r   = Math.round(10 * scale);

  const lineH = Math.max(box, fs) + Math.round(6 * scale);

  ctx.save();
  ctx.globalCompositeOperation = "source-over";
  ctx.font = `${fs}px sans-serif`;

  // measure widths
  const maxLabelW = Math.max(...thresholds.map(t => ctx.measureText(t.label || "").width), 0);
  const titleW = ctx.measureText(title || "").width;

  const panelW = Math.ceil(Math.max(titleW, box + gap + maxLabelW) + 2*pad);
  const panelH = Math.ceil(pad + fs + Math.round(10*scale) + thresholds.length*lineH + pad);

  let x = pad, y = pad;
  if (pos.includes("r")) x = W - panelW - pad;
  if (pos.includes("b")) y = H - panelH - pad;

  // panel background
  ctx.fillStyle = "rgba(255,255,255,0.80)";
  ctx.strokeStyle = "rgba(0,0,0,0.15)";
  ctx.lineWidth = Math.max(1, Math.round(1*scale));
  roundRect(ctx, x, y, panelW, panelH, r);
  ctx.fill();
  ctx.stroke();

  // title
  ctx.fillStyle = "rgba(0,0,0,0.70)";
  ctx.textBaseline = "top";
  ctx.fillText(title || "", x + pad, y + pad);

  // items
  let yy = y + pad + fs + Math.round(10*scale);
  for (const t of thresholds){
    ctx.fillStyle = t.color;
    ctx.fillRect(x + pad, yy + Math.round(2*scale), box, box);

    ctx.strokeStyle = "rgba(0,0,0,0.18)";
    ctx.lineWidth = Math.max(1, Math.round(1*scale));
    ctx.strokeRect(x + pad, yy + Math.round(2*scale), box, box);

    ctx.fillStyle = "rgba(0,0,0,0.70)";
    ctx.fillText(t.label || "", x + pad + box + gap, yy);
    yy += lineH;
  }

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function drawBaseLabels(ctx, W, H, pts){
  if (!$("labelsOn").checked) return;

  const font = $("labelFont").value || "sans-serif";
  const fs = Number($("labelFS").value);
  const col = $("labelColor").value;
  const outCol = $("labelOutline").value;
  const outW = Number($("labelOutlineW").value);
  const dx = Number($("labelDX").value);
  const dy = Number($("labelDY").value);

  ctx.save();
  ctx.globalCompositeOperation = "source-over";
  ctx.font = `${fs}px ${font}`;
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";

  const cell = Math.max(20, fs*2);
  const used = new Set();
  const keyOf = (x,y)=>`${Math.floor(x/cell)}:${Math.floor(y/cell)}`;

  for (let i=0;i<pts.length;i++){
    const {x,y} = lonLatToXY(pts[i].lon, pts[i].lat, W, H);
    const xx = x + dx, yy = y + dy;
    const key = keyOf(xx,yy);
    if (used.has(key)) continue;
    used.add(key);

    const text = pts[i].name;

    if (outW > 0){
      ctx.lineWidth = outW;
      ctx.strokeStyle = outCol;
      ctx.strokeText(text, xx, yy);
    }
    ctx.fillStyle = col;
    ctx.fillText(text, xx, yy);
  }

  ctx.restore();
}

async function regenerate(){
  const W = Number($("w").value);
  const H = Number($("h").value);
  const hexkm = Number($("hexkm").value);
  const rkm = Number($("rkm").value);
  const mode = $("mode").value;
  const bgMap = $("bgMap").checked;
  const transparent = $("transparent").checked;

  const cv = $("cv");
  cv.width = W; cv.height = H;
  const ctx = cv.getContext("2d", { willReadFrequently:true });

  // Background
  if (transparent){
    ctx.clearRect(0,0,W,H);
  } else if (bgMap){
    drawOfflineBg(ctx, W, H);
  } else {
    ctx.fillStyle = "white";
    ctx.fillRect(0,0,W,H);
  }

  // Load layers from same folder
  let countries = null, rivers = null;

  try {
    if ($("bordersOn").checked){
      setStatus("Loading countries.geojson ...");
      countries = await fetchJSON("./countries.geojson");
    }
  } catch(e) {
    setStatus(`countries.geojson not loaded: ${e.message}`);
  }

  try {
    if ($("watersOn").checked){
      setStatus("Loading waters_merged.geojson ...");
      rivers = await fetchJSON("./waters_merged.geojson"); // if you prefer waters.geojson: change this filename
    }
  } catch(e) {
    setStatus(`waters_merged.geojson not loaded: ${e.message}`);
  }

  // Draw waters under borders (optional)
  if ($("watersOn").checked && rivers){
    const col = $("watersColor").value;
    const w = Number($("watersW").value);
    const a = Number($("watersA").value);
    const feats = normalizeGeoJSON(rivers);
    setStatus(`Drawing waters: ${feats.length} features...`);
    for (const ft of feats){
      if (!ft.geometry) continue;
      drawGeometry(ctx, W, H, ft.geometry, {
        strokeStyle: hexToRgba(col,a),
        lineWidth: w,
        fillStyle: hexToRgba(col,a),
        fillAlpha: Math.min(0.35, a),
      });
    }
  }

  if ($("bordersOn").checked && countries){
    const col = $("bordersColor").value;
    const w = Number($("bordersW").value);
    const a = Number($("bordersA").value);
    const feats = normalizeGeoJSON(countries);
    setStatus(`Drawing borders: ${feats.length} features...`);
    for (const ft of feats){
      if (!ft.geometry) continue;
      drawGeometry(ctx, W, H, ft.geometry, {
        strokeStyle: hexToRgba(col,a),
        lineWidth: w
      });
    }
  }

  // Load CRTK list
  const crtkText = await loadCrtkText();
  const pts = parseSTR(crtkText);
  setStatus(`Bases in BBOX: ${pts.length}. Generating heatmap...`);

  drawHexDistanceLayer(ctx, W, H, pts, /*hexKm=*/hexkm, thresholds);
  // Heat layer
  const heat = drawHeatLayer(W, H, pts, rkm, mode);
  ctx.drawImage(heat, 0, 0);

  // Overlays
  drawBaseLabels(ctx, W, H, pts);

  const legendScale = Number($("legendScale").value || 1.0);
  drawLegendFromThresholds(
    ctx, W, H,
    thresholds,
    "Distance to nearest RTK base (km)",
    "br",
    legendScale
  );

  buildHexIndex(window.__hexR);
  window.__bases = pts; // hogy elérjük hoverben


  $("dl").disabled = false;
  setStatus("Done.");
}

const tip = document.getElementById("tip");
let lastHexId = -1;

function topKNearest(lat, lon, bases, k=5){
  const arr = bases.map(b => ({
    name: b.name,
    country: b.country,
    d: haversineKm(lat, lon, b.lat, b.lon)
  }));
  arr.sort((a,b)=>a.d-b.d);
  return arr.slice(0,k);
}

function showTip(e, hexId, bases){
  const h = hexCache[hexId];
  const top5 = topKNearest(h.lat, h.lon, bases, 5);

  const lines = top5.map(x =>
    `${x.d.toFixed(1)} km — ${escapeHtml(x.name)}${x.country ? " ("+escapeHtml(x.country)+")" : ""}`
  ).join("<br/>");

  tip.innerHTML = `
    <div style="font-weight:600;margin-bottom:6px">Nearest bases</div>
    <div class="mono" style="margin-bottom:6px">lat ${h.lat.toFixed(5)}, lon ${h.lon.toFixed(5)}</div>
    <div style="margin-bottom:6px">NEAR <b>${h.dNearest.toFixed(1)} km</b></div>
    <div>${lines}</div>
  `;
  tip.style.left = (e.clientX + 14) + "px";
  tip.style.top  = (e.clientY + 14) + "px";
  tip.style.display = "block";
}

function hideTip(){
  tip.style.display = "none";
  lastHexId = -1;
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}


$("regen").addEventListener("click", async () => {
  try { await regenerate(); }
  catch(e){ setStatus(`Error: ${e.message}`); console.error(e); }
});

$("dl").addEventListener("click", () => {
  const a = document.createElement("a");
  a.download = "rtk_heatmap.png";
  a.href = $("cv").toDataURL("image/png");
  a.click();
});

const cv = document.getElementById("cv");
cv.addEventListener("mousemove", (e) => {
  if (!window.__bases || !hexCache.length) return;

  const r = cv.getBoundingClientRect();
  const mx = (e.clientX - r.left) * (cv.width / r.width);
  const my = (e.clientY - r.top)  * (cv.height / r.height);

  const id = pickHex(mx, my);
  if (id < 0) { hideTip(); return; }
  if (id === lastHexId) { // csak mozgatjuk
    tip.style.left = (e.clientX + 14) + "px";
    tip.style.top  = (e.clientY + 14) + "px";
    return;
  }
  lastHexId = id;
  showTip(e, id, window.__bases);
});

cv.addEventListener("mouseleave", hideTip);

// Auto-generate on load
window.addEventListener("load", async () => {
  try { await regenerate(); }
  catch(e){
    setStatus(`Auto-generate failed: ${e.message}`);
    console.error(e);
  }
});
</script>
</body>
</html>
