<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KML Text Generator</title>
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    body { font-family: sans-serif; padding: 2rem; }
    label { display: block; margin-top: 1rem; }
    input, textarea, button { width: 100%; padding: 0.5rem; margin-top: 0.5rem; }
    #map { height: 400px; margin-top: 2rem; }
  </style>
</head>
<body>
  <h1>KML Text Generator</h1>
  Made with chatgpt :) <br/>
  <label>Text to display:<br><textarea id="textInput" placeholder="e.g. AgOpenGPS"></textarea></label>
  <label>Bottom-left corner (latitude, longitude):<input type="text" id="bottomLeft" placeholder="47.584276, 20.077679"></label>
  <label>Top-right corner (latitude, longitude):<input type="text" id="topRight" placeholder="47.584735, 20.079210"></label>
  <label>Rotation (degrees):<input type="number" id="rotation" value="0"></label>
  <button onclick="generateKML()">Generate KML</button>
  <button onclick="downloadKML()">Download KML</button>
  <br>Once downloaded, in AgOpenGPS do open from KML (this should load the outer field boundary) then add boundaries pick Multi KML and that should add all the inner boundaries. i.e. the letters.
  <button onclick="displayResults()">Display on Map</button>
  <textarea id="output" rows="15" placeholder="KML output will appear here..."></textarea>
  <div id="map"></div>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoiZ3VuaWNzYmEiLCJhIjoiY2x2emdtODF5MDJyZzJrcGg4anFocDMzZiJ9.5AHFwVRqLvSlNfCDx1musA';
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/light-v11',
      center: [19.51, 46.88],
      zoom: 15
    });

    const geoSample = { type: 'Feature', properties: {}, geometry: { type: 'Polygon', coordinates: [] } };

    const HEART_PATH = [
      [0, 300], [150, 450], [300, 300], [300, 150], [150, 0], [0, 150], [0, 300]
    ];

    async function generateKML() {
      const lines = document.getElementById('textInput').value.trim().split('\n').reverse();
      const [latMin, lonMin] = document.getElementById('bottomLeft').value.split(',').map(Number);
      const [latMax, lonMax] = document.getElementById('topRight').value.split(',').map(Number);
      const rotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
      const latSize = latMax - latMin;
      const lonSize = lonMax - lonMin;
      const centerLat = (latMin + latMax) / 2;
      const centerLon = (lonMin + lonMax) / 2;
      const font = await opentype.load('https://cdn.jsdelivr.net/npm/webr@0.4.2/dist/vfs/usr/share/fonts/NotoSansMono-Regular.ttf');

      const totalLines = lines.length;
      const lineHeight = 500;
      const fullTextHeight = totalLines * lineHeight;
      const scale = Math.min(lonSize / 5000, latSize / fullTextHeight);
      console.log("aa " + (lonSize / 5000) + " + " + (latSize / fullTextHeight));

      let kml = `<?xml version="1.0"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n  <Document>\n`;
      kml += `    <Placemark>\n      <name>Boundary</name>\n      <Style><PolyStyle><color>1AFFFFFF</color></PolyStyle></Style>\n      <Polygon>\n        <altitudeMode>clampToGround</altitudeMode>\n        <outerBoundaryIs><LinearRing><coordinates>`;
      kml += `${lonMin},${latMin},0 ${lonMax},${latMin},0 ${lonMax},${latMax},0 ${lonMin},${latMax},0 ${lonMin},${latMin},0`;
      kml += `</coordinates></LinearRing></outerBoundaryIs>\n      </Polygon>\n    </Placemark>\n`;

      lines.forEach((line, lineIdx) => {
        let totalWidth = 0;
        const letters = [...line].map(char => {
          const glyph = font.charToGlyph(char);
          const path = glyph.getPath(0, 0, 1000);
          const width = (glyph.advanceWidth || 1000);
          totalWidth += width * 0.85;
          return { path, width, char };
        });

        let xOffset = -totalWidth / 2;
        const yOffset = (lineIdx - totalLines / 2 + 0.5) * lineHeight * scale;

        letters.forEach(({ path, width, char }, i) => {
          const coords = [];
          const xTranslate = xOffset + width / 2;


            path.commands.forEach(cmd => {
              if (cmd.x !== undefined && cmd.y !== undefined) {
                let x = (cmd.x + xTranslate) * scale;
                let y = (-cmd.y * scale) + yOffset;
                const xRot = x * Math.cos(rotation) - y * Math.sin(rotation);
                const yRot = x * Math.sin(rotation) + y * Math.cos(rotation);
                const lon = centerLon + xRot;
                const lat = centerLat + yRot;
                coords.push(`${lon},${lat},0`);
              }
            });

          xOffset += width * 0.95;
          if (coords.length > 2) coords.push(coords[0]);
          kml += `\n    <Placemark>\n      <name>Letter_${lineIdx}_${i}_${char.replace("<","").replace("\\","")}</name>\n\n      <Polygon>\n        <altitudeMode>clampToGround</altitudeMode>\n        <outerBoundaryIs><LinearRing><coordinates>${coords.join(' ')}</coordinates></LinearRing></outerBoundaryIs>\n      </Polygon>\n    </Placemark>\n`;
        });
      });

      kml += `  </Document>\n</kml>`;
      document.getElementById('output').value = kml;
    }

    function downloadKML() {
      const blob = new Blob([document.getElementById('output').value], { type: 'application/vnd.google-earth.kml+xml' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'text.kml';
      link.download = document.getElementById('textInput').value.trim().split('\n')[0] + ".kml";
      link.click();
    }

    function displayResults() {
      const raw = document.getElementById('output').value;
      const matches = [...raw.matchAll(/<coordinates>([^<]*)<\/coordinates>/g)].map(m => m[1]);
      const polygons = matches.map(str => str.trim().split(' ').map(pair => pair.split(',').map(Number)));

      const geo = JSON.parse(JSON.stringify(geoSample));
      geo.geometry.coordinates = polygons;

      if (map.getSource('overlay')) {
        map.removeLayer('overlay');
        map.removeSource('overlay');
      }
      map.addSource('overlay', { type: 'geojson', data: geo });
      map.addLayer({
        id: 'overlay',
        type: 'fill',
        source: 'overlay',
        paint: {
          'fill-color': '#'+Math.floor(Math.random()*16777215).toString(16),
          'fill-opacity': 0.3
        }
      });

      const bounds = turf.bbox(geo);
      map.fitBounds([[bounds[0], bounds[1]], [bounds[2], bounds[3]]], { padding: 40 });
    }
  </script>
</body>
</html>
